# Phase 2 Theory — Spring Boot 실전 역량 (구체화)

## 학습 목표 (2주)
- 주문/결제 유스케이스에서 트랜잭션 경계를 명확히 설계한다.
- JPA 성능 병목을 SQL 로그 기반으로 식별/개선한다.
- 운영 관점(로그/지표/에러 표준)까지 포함해 API를 완성한다.

## Week 1
1. 계층 설계 + 유스케이스 흐름
2. 트랜잭션 경계/전파/격리수준 기본
3. JPA N+1 재현 및 해결

## Week 2
1. 예외 체계/에러 응답 표준화
2. API/통합 테스트 전략
3. 주문 생성 안정화 케이스 스터디

---

## 1) 주문 생성 유스케이스 기준 계층 분리
- Controller: DTO 검증 + 응답 포맷
- Application Service: `placeOrder()` orchestration
- Domain: 쿠폰 유효성, 주문 상태 전이
- Infra: 결제사 API, Repository

### 예시 유스케이스 흐름
1. 입력 검증
2. 쿠폰 정책 검증
3. 재고 확인
4. 주문 생성(PENDING)
5. 결제 시도
6. 성공: PAID / 실패: PAYMENT_FAILED

---

## 2) 트랜잭션 설계 규칙
- 외부 결제 API 호출은 장시간 대기 가능 → DB 트랜잭션 최소화
- "주문 저장"과 "결제 승인"을 분리할지 반드시 ADR로 근거 남김
- 실패 전략
  - 동기 실패: 상태 전이 + 사유 저장
  - 비동기 실패: 재시도 큐 + 최종 실패 알림

## 3) JPA 성능 체크
- N+1 탐지: 쿼리 개수 카운팅
- fetch join 사용 시 페이징 주의
- keyset pagination 검토 기준
  - 대량 페이지 이동
  - 정렬 기준이 고정된 경우
- 벌크 업데이트 후 `clear()` 수행 규칙

## 4) 에러/로그 표준
### 에러 응답 예시
```json
{
  "code": "ORDER-409-001",
  "message": "재고가 부족합니다.",
  "traceId": "tr-abc-123",
  "timestamp": "2026-02-17T10:30:00Z"
}
```

### 로그 필수 필드
- traceId, userId, orderId, couponCode, paymentProvider

## 5) 테스트 계층
- 단위: 쿠폰 정책/상태 전이
- 통합: JPA 쿼리/트랜잭션 롤백
- API: 계약 검증(상태코드/응답 스키마)

## 6) 성공 기준
- [ ] 주문 생성/결제 실패 플로우를 다이어그램으로 설명 가능
- [ ] N+1 개선 전/후 SQL 차이를 제시 가능
- [ ] 오류 응답/로그 표준이 모든 API에 일관 적용
